package main

import (
	"os"
	"io/ioutil"
	"go/ast"
	"go/token"
	"log"
	"go/parser"
	"strings"
	"html/template"
	"bytes"
	"golang.org/x/tools/imports"
)

func main()  {
	gofile := os.Getenv("GOFILE")
	fset := token.NewFileSet()
	src,err := ioutil.ReadFile(gofile)
	if err != nil {
		log.Fatal(err)
	}
	f,err := parser.ParseFile(fset,gofile,src, 0)
	if err != nil {
		log.Fatal(err)
	}

	data := struct {
		Package string
		Aggregate       string
		Events          []string
		Commands        []string
		CommandHandlers []string
		EventAppliers   []string
	}{
		Package: os.Getenv("GOPACKAGE"),
	}
	//ast.Walk(DeclarationVisitor{},f)
	ast.Inspect(f, func(n ast.Node) bool {
		typ,ok := n.(*ast.TypeSpec)
		if ok {
			if strings.HasSuffix(typ.Name.Name,"Event"){
				data.Events = append(data.Events,typ.Name.Name)
			}
			if strings.HasSuffix(typ.Name.Name,"Command"){
				data.Commands = append(data.Commands,typ.Name.Name)
			}
			if strings.HasSuffix(typ.Name.Name,"Aggregate"){
				data.Aggregate = typ.Name.Name
			}
		}
		fn,ok := n.(*ast.FuncDecl)
		if ok {
			if strings.HasPrefix(fn.Name.Name,"Apply") && strings.HasSuffix(fn.Name.Name,"Event"){
				data.EventAppliers = append(data.EventAppliers,fn.Name.Name)
			}
			if strings.HasPrefix(fn.Name.Name,"Handle") && strings.HasSuffix(fn.Name.Name,"Command"){
				data.CommandHandlers = append(data.CommandHandlers,fn.Name.Name)
			}
		}
		return true
	})

	tmpl := template.New("")
	tmpl.Parse(`// Code generated by cqrs-aggregate. DO NOT EDIT.
package {{.Package}}

const (
	{{.Aggregate}}Type cqrs.AggregateType = "{{.Aggregate}}"
{{range .Commands}}
	{{.}}Type cqrs.CommandType = "{{.}}"
{{end}}
{{range .Events}}
	{{.}}Type cqrs.EventType = "{{.}}"
{{end}}
)

func init(){
	cqrs.RegisterAggregate({{.Aggregate}}Type,{{.Aggregate}}{}.Aggr)
	{{range .Events}}
	cqrs.RegisterEvent({{.}}Type,{{.}}{})
	{{end}}
}

func (a {{.Aggregate}}) Aggr() *cqrs.Aggregate {
	aggr := &cqrs.Aggregate{
		Impl: &a,
		AggregateID: &cqrs.AggregateID{
			Type: {{.Aggregate}}Type,
		},
	}
	a.Aggregate = aggr
	return aggr
}

func (a *{{.Aggregate}}) Apply(ctx context.Context,e *cqrs.Event) error {
	/*if !a.ReplayMode() && !a.Pending(e){
		return a.Aggregate.Apply(e)
	}*/
	switch e.Type {
	{{range .Events}}
	case {{.}}Type:
		if err := a.Apply{{.}}(ctx,e.Impl.(*{{.}})); err != nil {
			return err
		}
	{{end}}
	default:
		panic("unknown event type: "+e.Type)
	}
	return nil
}

func (a *{{.Aggregate}}) Handle(ctx context.Context,c *cqrs.Command) error {
	switch c.Type{
	{{range .Commands}}
	case {{.}}Type:
		return a.Handle{{.}}(ctx,c.Impl.(*{{.}}))
	{{end}}
	default:
		panic("unknown command type: "+c.Type)
	}
}

{{range .Commands}}
func (c {{.}}) Dispatch(ctx context.Context, id string, version int) error {
	if c.Command != nil {
		return fmt.Errorf("this command has already been dispatched with id: %s",c.Command.ID)
	}
	cid := cqrs.IDFunc()
	cmd :=  &cqrs.Command{
		ID:   cid,
		CausationID: cid,
		CorrelationID: cid,
		Type: {{.}}Type,
		Aggregate: cqrs.AggregateID{
			ID:      id,
			Version: version,
			Type:    {{$.Aggregate}}Type,
		},
		Impl: &c,
	}
	c.Command = cmd
	return cqrs.DispatchCommand(ctx,cmd)
}
{{end}}
{{range .Events}}
func (e {{.}}) Apply(ctx context.Context,aggregate *cqrs.Aggregate, causedBy *cqrs.Command) error {
	event := &cqrs.Event{
		ID:          cqrs.IDFunc(),
		CausationID: causedBy.ID,
		CorrelationID: causedBy.CorrelationID,
		Type:        {{.}}Type,
		Aggregate:   causedBy.Aggregate,
		Impl:         &e,
	}
	e.Event = event
	return aggregate.Apply(ctx,event)
}
{{end}}

`)
	buffer := &bytes.Buffer{}
	tmpl.Execute(buffer,&data)
	output := "gen_"+gofile
	buf,err := imports.Process(output,buffer.Bytes(),nil)
	if err != nil {
		log.Fatal(err)
	}
	ioutil.WriteFile(output,buf,0644)
}
